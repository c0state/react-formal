(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{"Q/E7":function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return i})),t.d(n,"default",(function(){return d}));t("rGqo"),t("yt8O"),t("Btvt"),t("RW0V"),t("91GP"),t("q1tI");var a=t("7ljp"),r=t("eXqk");var i={},l={_frontmatter:i},o=r.default;function d(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,["components"]);return Object(a.mdx)(o,Object.assign({},l,t,{components:n,mdxType:"MDXLayout"}),Object(a.mdx)("h1",{id:"migration-to-v2"},"Migration to v2"),Object(a.mdx)("p",null,"Version 2.0.0 focuses on adding robust hooks support as well as streamlining the public\nAPI towards simplicity and consistency. It also adds first class TypeScript support!"),Object(a.mdx)("h2",{id:"key-features"},"Key Features"),Object(a.mdx)("ul",null,Object(a.mdx)("li",{parentName:"ul"},"New hooks for custom fields and common use-cases makes accessing Form data significantly easier",Object(a.mdx)("ul",{parentName:"li"},Object(a.mdx)("li",{parentName:"ul"},Object(a.mdx)("inlineCode",{parentName:"li"},"useFormValue")),Object(a.mdx)("li",{parentName:"ul"},Object(a.mdx)("inlineCode",{parentName:"li"},"useField")),Object(a.mdx)("li",{parentName:"ul"},Object(a.mdx)("inlineCode",{parentName:"li"},"useFieldArray")),Object(a.mdx)("li",{parentName:"ul"},Object(a.mdx)("inlineCode",{parentName:"li"},"useFormSubmit")),Object(a.mdx)("li",{parentName:"ul"},Object(a.mdx)("inlineCode",{parentName:"li"},"useErrors")),Object(a.mdx)("li",{parentName:"ul"},Object(a.mdx)("inlineCode",{parentName:"li"},"useTouched")))),Object(a.mdx)("li",{parentName:"ul"},"Out-of-the-box support for ",Object(a.mdx)("inlineCode",{parentName:"li"},"<select multiple>")," as well as checkbox groups"),Object(a.mdx)("li",{parentName:"ul"},"Better ",Object(a.mdx)("inlineCode",{parentName:"li"},"FieldArray")," validation behavior; arrayHelpers only trigger validation on the list itself, not nested fields"),Object(a.mdx)("li",{parentName:"ul"},"Library is now written in TypeScript.")),Object(a.mdx)("h2",{id:"breaking-changes"},"Breaking Changes"),Object(a.mdx)("p",null,"There is lot of rewritten code, so there may be subtle changes that I've missed. Please\ntest in your apps thoroughly."),Object(a.mdx)("h3",{id:"package-exports-have-been-rearranged"},"Package exports have been rearranged"),Object(a.mdx)("p",null,"Previously, most library components and utils were exported as static properties\nof the ",Object(a.mdx)("inlineCode",{parentName:"p"},"<Form>")," component as well as being named exports from the package. For\nESM consumers the default export is the ",Object(a.mdx)("inlineCode",{parentName:"p"},"<Form>")," component and\nthe ",Object(a.mdx)("inlineCode",{parentName:"p"},"<Field>"),", ",Object(a.mdx)("inlineCode",{parentName:"p"},"<FieldArray>"),", ",Object(a.mdx)("inlineCode",{parentName:"p"},"<Message>"),", ",Object(a.mdx)("inlineCode",{parentName:"p"},"<Submit>"),", and ",Object(a.mdx)("inlineCode",{parentName:"p"},"<Summary>")," components\nare still static properties of Form:"),Object(a.mdx)("pre",null,Object(a.mdx)("code",Object.assign({parentName:"pre"},{className:"language-jsx",metastring:"static",static:!0}),"import Form from 'react-formal';\n\n<Form>\n  <Form.Field />\n</Form>;\n")),Object(a.mdx)("p",null,"Every thing else is exported as a named export including an object called ",Object(a.mdx)("inlineCode",{parentName:"p"},"formStatics"),"\nwhich is all the static properties on Form."),Object(a.mdx)("pre",null,Object(a.mdx)("code",Object.assign({parentName:"pre"},{className:"language-jsx",metastring:"static",static:!0}),"import { useField, setter, toFormErrors } from 'react-formal';\n")),Object(a.mdx)("p",null,"For CommonJS consumers the import is the Form component with all other exports as static properties."),Object(a.mdx)("h3",{id:"field-render-prop-arguments"},"Field render prop arguments"),Object(a.mdx)("p",null,"Instead of passing a single ",Object(a.mdx)("inlineCode",{parentName:"p"},"props")," argument and the resolved Input, Field and FieldArrays\nnow pass props and ",Object(a.mdx)("inlineCode",{parentName:"p"},"meta")," as seperate arguments. The resolved input has been removed\nentirely as it was unnecessary for custom components. For details about how fields\nresolve to ",Object(a.mdx)("em",{parentName:"p"},"native")," elements field ",Object(a.mdx)("inlineCode",{parentName:"p"},"meta")," now contains ",Object(a.mdx)("inlineCode",{parentName:"p"},"nativeTagName")," and ",Object(a.mdx)("inlineCode",{parentName:"p"},"nativeType")),Object(a.mdx)("pre",null,Object(a.mdx)("code",Object.assign({parentName:"pre"},{className:"language-jsx",metastring:"static",static:!0}),'<Form.Field name="birthDate">\n  {(props, meta) => <DatePicker {...props} />}\n</Form.Field>\n')),Object(a.mdx)("p",null,"For very custom ",Object(a.mdx)("inlineCode",{parentName:"p"},"Field")," components consider ",Object(a.mdx)("inlineCode",{parentName:"p"},"useField")," and friends."),Object(a.mdx)("h3",{id:"change-events---validateon"},"Change: ",Object(a.mdx)("inlineCode",{parentName:"h3"},"events")," -> ",Object(a.mdx)("inlineCode",{parentName:"h3"},"validateOn")),Object(a.mdx)("p",null,"The validation ",Object(a.mdx)("inlineCode",{parentName:"p"},"events")," prop has been changed to ",Object(a.mdx)("inlineCode",{parentName:"p"},"validateOn")," and limited to only ",Object(a.mdx)("inlineCode",{parentName:"p"},"change")," and ",Object(a.mdx)("inlineCode",{parentName:"p"},"blur"),".\nArbitrary events cannot be configured any longer. To support other sorts of event\nhandlers use the Field render prop."),Object(a.mdx)("pre",null,Object(a.mdx)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"<Field>\n  {({ onBlur, ...pros }) => <MyInput onValidate={onBlur} {...props} />}\n</Field>\n")),Object(a.mdx)("h3",{id:"fields-always-inject-onchange"},"Field's ",Object(a.mdx)("em",{parentName:"h3"},"always")," inject ",Object(a.mdx)("inlineCode",{parentName:"h3"},"onChange")),Object(a.mdx)("p",null,"Previously Fields would only inject handlers for their configured ",Object(a.mdx)("inlineCode",{parentName:"p"},"events"),". This\nmeant that when set to ",Object(a.mdx)("inlineCode",{parentName:"p"},"null")," a Field could not trigger updates. This has been fixed, so\n",Object(a.mdx)("inlineCode",{parentName:"p"},"events")," (now ",Object(a.mdx)("inlineCode",{parentName:"p"},"validateOn"),") now refer exclusively to handlers ",Object(a.mdx)("em",{parentName:"p"},"that trigger validation")," and ",Object(a.mdx)("inlineCode",{parentName:"p"},"onChange")," is always\ninjected, even when events is ",Object(a.mdx)("inlineCode",{parentName:"p"},"null"),"."),Object(a.mdx)("p",null,"Note that ",Object(a.mdx)("inlineCode",{parentName:"p"},"onChange")," can still trigger validation, e.g.\n",Object(a.mdx)("inlineCode",{parentName:"p"},'validateOn="change"')," will inject an ",Object(a.mdx)("inlineCode",{parentName:"p"},"onChange")," handler that triggers an update as well as validation,\n",Object(a.mdx)("inlineCode",{parentName:"p"},"validateOn={null}")," will still inject ",Object(a.mdx)("inlineCode",{parentName:"p"},"onChange")," but it will ",Object(a.mdx)("em",{parentName:"p"},"only")," trigger an update\nto the field value, not validation."),Object(a.mdx)("h3",{id:"fieldarray-render-prop-arguments"},"FieldArray render prop arguments"),Object(a.mdx)("p",null,Object(a.mdx)("inlineCode",{parentName:"p"},"<FieldArray>")," have switched to be entirely non-presentational components. Meaning,\nthey no longer accept an ",Object(a.mdx)("inlineCode",{parentName:"p"},"as")," prop or element ",Object(a.mdx)("inlineCode",{parentName:"p"},"children"),". It's generally recommended\nthat FieldArray be used to compose other ",Object(a.mdx)("inlineCode",{parentName:"p"},"Field"),"s via the render prop (but not required)."),Object(a.mdx)("p",null,"For uses existing renderProp usage the arguments are now:"),Object(a.mdx)("pre",null,Object(a.mdx)("code",Object.assign({parentName:"pre"},{className:"language-jsx",metastring:"static",static:!0}),"<Form.FieldArray>\n  {(values, arrayHelpers, meta) => ... }\n</Form.FieldArray>\n")),Object(a.mdx)("p",null,Object(a.mdx)("inlineCode",{parentName:"p"},"useFieldArray")," is also now available as an alternative to render props."),Object(a.mdx)("h4",{id:"migrating-fieldarray-components"},"Migrating FieldArray Components"),Object(a.mdx)("p",null,"This is likely an uncommon pattern, but Field Arrays like the following:"),Object(a.mdx)("pre",null,Object(a.mdx)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"<Form.FieldArray as={MyListComponent} />\n")),Object(a.mdx)("p",null,"Will no longer work, instead switch to the render prop and pass the helpers and values\nin as props to your component, or take ad avantage of ",Object(a.mdx)("inlineCode",{parentName:"p"},"useFieldArray")," in MyListComponent."),Object(a.mdx)("pre",null,Object(a.mdx)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"<Form.FieldArray>\n  {(values, arrayHelpers, meta) => (\n    <MyListComponent values={values} helpers={arrayHelpers} meta={meta} />\n  )}\n</Form.FieldArray>\n")),Object(a.mdx)("h3",{id:"fieldarray-validation"},"FieldArray validation"),Object(a.mdx)("p",null,"Previously, ",Object(a.mdx)("inlineCode",{parentName:"p"},"<FieldArray>"),"s would trigger validation the same as ",Object(a.mdx)("inlineCode",{parentName:"p"},"<Field>"),"s, validating\nthe entire branch below their ",Object(a.mdx)("inlineCode",{parentName:"p"},"name"),". Now validation is ",Object(a.mdx)("em",{parentName:"p"},"only")," triggered for the list itself.\nPractically this means that it's no longer required to set ",Object(a.mdx)("inlineCode",{parentName:"p"},"events={null}")," on FieldArrays as a well\nof disabling top level validation."))}d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-migration-v-2-mdx-274aba37ffe2f1c0e656.js.map